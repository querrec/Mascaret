//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.3
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\Users\Utilisateur\Developpement\MascaretGit\MascaretGit\Dev\CS\Mascaret\Mascaret\VEHA\Kernel\OCLExpression.g4 by ANTLR 4.3

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591

namespace Mascaret {

using System;
using System.Collections;
using System.Collections.Generic;

using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.3")]
[System.CLSCompliant(false)]
public partial class OCLExpressionParser : Parser {
	public const int
		T__4=1, T__3=2, T__2=3, T__1=4, T__0=5, LPAREN=6, RPAREN=7, COLON=8, EQUAL=9, 
		NEQUAL=10, LT=11, GT=12, LE=13, GE=14, RARROW=15, DOTDOT=16, DOT=17, POUND=18, 
		SEMICOL=19, PLUS=20, MINUS=21, MULT=22, DIVIDE=23, DIGIT=24, STRING=25, 
		WS=26;
	public static readonly string[] tokenNames = {
		"<INVALID>", "'xor'", "'or'", "'implies'", "'and'", "'not'", "'('", "')'", 
		"':'", "'='", "'<>'", "'<'", "'>'", "'<='", "'>='", "'->'", "'..'", "'.'", 
		"'#'", "';'", "'+'", "'-'", "'*'", "'/'", "DIGIT", "STRING", "WS"
	};
	public const int
		RULE_expression = 0, RULE_logicalexpression = 1, RULE_relationexpression = 2, 
		RULE_additiveexpression = 3, RULE_multiplicativeexpression = 4, RULE_unaryexpression = 5, 
		RULE_postfixexpression = 6, RULE_primaryexpression = 7, RULE_propertycall = 8, 
		RULE_attributecall = 9, RULE_logicaloperator = 10, RULE_relationaloperator = 11, 
		RULE_addoperator = 12, RULE_multiplyoperator = 13, RULE_unaryoperator = 14, 
		RULE_numericalconstant = 15, RULE_integer = 16, RULE_float = 17;
	public static readonly string[] ruleNames = {
		"expression", "logicalexpression", "relationexpression", "additiveexpression", 
		"multiplicativeexpression", "unaryexpression", "postfixexpression", "primaryexpression", 
		"propertycall", "attributecall", "logicaloperator", "relationaloperator", 
		"addoperator", "multiplyoperator", "unaryoperator", "numericalconstant", 
		"integer", "float"
	};

	public override string GrammarFileName { get { return "OCLExpression.g4"; } }

	public override string[] TokenNames { get { return tokenNames; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }


		public Dictionary<string, ValueSpecification> context;
		private ValueSpecification lvalue;
		public ValueSpecification value;


	public OCLExpressionParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class ExpressionContext : ParserRuleContext {
		public LogicalexpressionContext logicalexpression() {
			return GetRuleContext<LogicalexpressionContext>(0);
		}
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.EnterExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.ExitExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IOCLExpressionVisitor<TResult> typedVisitor = visitor as IOCLExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		ExpressionContext _localctx = new ExpressionContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_expression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 36; logicalexpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LogicalexpressionContext : ParserRuleContext {
		public LogicaloperatorContext[] logicaloperator() {
			return GetRuleContexts<LogicaloperatorContext>();
		}
		public LogicaloperatorContext logicaloperator(int i) {
			return GetRuleContext<LogicaloperatorContext>(i);
		}
		public RelationexpressionContext[] relationexpression() {
			return GetRuleContexts<RelationexpressionContext>();
		}
		public RelationexpressionContext relationexpression(int i) {
			return GetRuleContext<RelationexpressionContext>(i);
		}
		public LogicalexpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_logicalexpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.EnterLogicalexpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.ExitLogicalexpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IOCLExpressionVisitor<TResult> typedVisitor = visitor as IOCLExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalexpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LogicalexpressionContext logicalexpression() {
		LogicalexpressionContext _localctx = new LogicalexpressionContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_logicalexpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 38; relationexpression();
			State = 44;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__4) | (1L << T__3) | (1L << T__2) | (1L << T__1))) != 0)) {
				{
				{
				State = 39; logicaloperator();
				State = 40; relationexpression();
				}
				}
				State = 46;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RelationexpressionContext : ParserRuleContext {
		public AdditiveexpressionContext[] additiveexpression() {
			return GetRuleContexts<AdditiveexpressionContext>();
		}
		public AdditiveexpressionContext additiveexpression(int i) {
			return GetRuleContext<AdditiveexpressionContext>(i);
		}
		public RelationexpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relationexpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.EnterRelationexpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.ExitRelationexpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IOCLExpressionVisitor<TResult> typedVisitor = visitor as IOCLExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelationexpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RelationexpressionContext relationexpression() {
		RelationexpressionContext _localctx = new RelationexpressionContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_relationexpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 47; additiveexpression();
			lvalue = value;
			State = 75;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << EQUAL) | (1L << NEQUAL) | (1L << LT) | (1L << GT) | (1L << LE) | (1L << GE))) != 0)) {
				{
				State = 73;
				switch (_input.La(1)) {
				case EQUAL:
					{
					{
					State = 49; Match(EQUAL);
					State = 50; additiveexpression();
					double l = ((LiteralReal)lvalue).RValue; double r = ((LiteralReal)value).RValue; if (l == r) value = new LiteralBoolean(true); else value = new LiteralBoolean(false);
					}
					}
					break;
				case NEQUAL:
					{
					{
					State = 53; Match(NEQUAL);
					State = 54; additiveexpression();
					double l = ((LiteralReal)lvalue).RValue; double r = ((LiteralReal)value).RValue; if (l != r) value = new LiteralBoolean(true); else value = new LiteralBoolean(false);
					}
					}
					break;
				case LT:
					{
					{
					State = 57; Match(LT);
					State = 58; additiveexpression();
					double l = ((LiteralReal)lvalue).RValue; double r = ((LiteralReal)value).RValue; if (l < r) value = new LiteralBoolean(true); else value = new LiteralBoolean(false);
					}
					}
					break;
				case GT:
					{
					{
					State = 61; Match(GT);
					State = 62; additiveexpression();
					double l = ((LiteralReal)lvalue).RValue; double r = ((LiteralReal)value).RValue; if (l > r) value = new LiteralBoolean(true); else value = new LiteralBoolean(false);
					}
					}
					break;
				case GE:
					{
					{
					State = 65; Match(GE);
					State = 66; additiveexpression();
					double l = ((LiteralReal)lvalue).RValue; double r = ((LiteralReal)value).RValue; if (l >= r) value = new LiteralBoolean(true); else value = new LiteralBoolean(false);
					}
					}
					break;
				case LE:
					{
					{
					State = 69; Match(LE);
					State = 70; additiveexpression();
					double l = ((LiteralReal)lvalue).RValue; double r = ((LiteralReal)value).RValue; if (l <= r) value = new LiteralBoolean(true); else value = new LiteralBoolean(false);
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 77;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AdditiveexpressionContext : ParserRuleContext {
		public AddoperatorContext[] addoperator() {
			return GetRuleContexts<AddoperatorContext>();
		}
		public MultiplicativeexpressionContext multiplicativeexpression(int i) {
			return GetRuleContext<MultiplicativeexpressionContext>(i);
		}
		public AddoperatorContext addoperator(int i) {
			return GetRuleContext<AddoperatorContext>(i);
		}
		public MultiplicativeexpressionContext[] multiplicativeexpression() {
			return GetRuleContexts<MultiplicativeexpressionContext>();
		}
		public AdditiveexpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_additiveexpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.EnterAdditiveexpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.ExitAdditiveexpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IOCLExpressionVisitor<TResult> typedVisitor = visitor as IOCLExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAdditiveexpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AdditiveexpressionContext additiveexpression() {
		AdditiveexpressionContext _localctx = new AdditiveexpressionContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_additiveexpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 78; multiplicativeexpression();
			State = 84;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==PLUS || _la==MINUS) {
				{
				{
				State = 79; addoperator();
				State = 80; multiplicativeexpression();
				}
				}
				State = 86;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultiplicativeexpressionContext : ParserRuleContext {
		public UnaryexpressionContext unaryexpression(int i) {
			return GetRuleContext<UnaryexpressionContext>(i);
		}
		public UnaryexpressionContext[] unaryexpression() {
			return GetRuleContexts<UnaryexpressionContext>();
		}
		public MultiplyoperatorContext multiplyoperator(int i) {
			return GetRuleContext<MultiplyoperatorContext>(i);
		}
		public MultiplyoperatorContext[] multiplyoperator() {
			return GetRuleContexts<MultiplyoperatorContext>();
		}
		public MultiplicativeexpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiplicativeexpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.EnterMultiplicativeexpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.ExitMultiplicativeexpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IOCLExpressionVisitor<TResult> typedVisitor = visitor as IOCLExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiplicativeexpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MultiplicativeexpressionContext multiplicativeexpression() {
		MultiplicativeexpressionContext _localctx = new MultiplicativeexpressionContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_multiplicativeexpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 87; unaryexpression();
			State = 93;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==MULT || _la==DIVIDE) {
				{
				{
				State = 88; multiplyoperator();
				State = 89; unaryexpression();
				}
				}
				State = 95;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnaryexpressionContext : ParserRuleContext {
		public PostfixexpressionContext postfixexpression() {
			return GetRuleContext<PostfixexpressionContext>(0);
		}
		public UnaryoperatorContext unaryoperator() {
			return GetRuleContext<UnaryoperatorContext>(0);
		}
		public UnaryexpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unaryexpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.EnterUnaryexpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.ExitUnaryexpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IOCLExpressionVisitor<TResult> typedVisitor = visitor as IOCLExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnaryexpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnaryexpressionContext unaryexpression() {
		UnaryexpressionContext _localctx = new UnaryexpressionContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_unaryexpression);
		try {
			State = 100;
			switch (_input.La(1)) {
			case T__0:
			case MINUS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 96; unaryoperator();
				State = 97; postfixexpression();
				}
				break;
			case DIGIT:
			case STRING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 99; postfixexpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PostfixexpressionContext : ParserRuleContext {
		public PropertycallContext _propertycall;
		public ITerminalNode[] DOT() { return GetTokens(OCLExpressionParser.DOT); }
		public PrimaryexpressionContext primaryexpression() {
			return GetRuleContext<PrimaryexpressionContext>(0);
		}
		public PropertycallContext propertycall(int i) {
			return GetRuleContext<PropertycallContext>(i);
		}
		public PropertycallContext[] propertycall() {
			return GetRuleContexts<PropertycallContext>();
		}
		public ITerminalNode DOT(int i) {
			return GetToken(OCLExpressionParser.DOT, i);
		}
		public PostfixexpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_postfixexpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.EnterPostfixexpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.ExitPostfixexpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IOCLExpressionVisitor<TResult> typedVisitor = visitor as IOCLExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPostfixexpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PostfixexpressionContext postfixexpression() {
		PostfixexpressionContext _localctx = new PostfixexpressionContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_postfixexpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 102; primaryexpression();
			State = 109;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==DOT) {
				{
				{
				State = 103; Match(DOT);
				State = 104; _localctx._propertycall = propertycall();
				value = (((InstanceValue)value).SpecValue).Slots[(_localctx._propertycall!=null?_input.GetText(_localctx._propertycall.start,_localctx._propertycall.stop):null)].getValue(); 
				}
				}
				State = 111;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrimaryexpressionContext : ParserRuleContext {
		public IToken _STRING;
		public NumericalconstantContext _numericalconstant;
		public NumericalconstantContext numericalconstant() {
			return GetRuleContext<NumericalconstantContext>(0);
		}
		public ITerminalNode STRING() { return GetToken(OCLExpressionParser.STRING, 0); }
		public PrimaryexpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_primaryexpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.EnterPrimaryexpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.ExitPrimaryexpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IOCLExpressionVisitor<TResult> typedVisitor = visitor as IOCLExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrimaryexpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PrimaryexpressionContext primaryexpression() {
		PrimaryexpressionContext _localctx = new PrimaryexpressionContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_primaryexpression);
		try {
			State = 117;
			switch (_input.La(1)) {
			case STRING:
				EnterOuterAlt(_localctx, 1);
				{
				State = 112; _localctx._STRING = Match(STRING);
				 value = context[(_localctx._STRING!=null?_localctx._STRING.Text:null)];
				}
				break;
			case DIGIT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 114; _localctx._numericalconstant = numericalconstant();
				value = new LiteralReal((_localctx._numericalconstant!=null?_input.GetText(_localctx._numericalconstant.start,_localctx._numericalconstant.stop):null));
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropertycallContext : ParserRuleContext {
		public AttributecallContext attributecall() {
			return GetRuleContext<AttributecallContext>(0);
		}
		public PropertycallContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propertycall; } }
		public override void EnterRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.EnterPropertycall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.ExitPropertycall(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IOCLExpressionVisitor<TResult> typedVisitor = visitor as IOCLExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropertycall(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropertycallContext propertycall() {
		PropertycallContext _localctx = new PropertycallContext(_ctx, State);
		EnterRule(_localctx, 16, RULE_propertycall);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 119; attributecall();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AttributecallContext : ParserRuleContext {
		public ITerminalNode STRING() { return GetToken(OCLExpressionParser.STRING, 0); }
		public AttributecallContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_attributecall; } }
		public override void EnterRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.EnterAttributecall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.ExitAttributecall(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IOCLExpressionVisitor<TResult> typedVisitor = visitor as IOCLExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAttributecall(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AttributecallContext attributecall() {
		AttributecallContext _localctx = new AttributecallContext(_ctx, State);
		EnterRule(_localctx, 18, RULE_attributecall);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 121; Match(STRING);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LogicaloperatorContext : ParserRuleContext {
		public LogicaloperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_logicaloperator; } }
		public override void EnterRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.EnterLogicaloperator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.ExitLogicaloperator(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IOCLExpressionVisitor<TResult> typedVisitor = visitor as IOCLExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicaloperator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LogicaloperatorContext logicaloperator() {
		LogicaloperatorContext _localctx = new LogicaloperatorContext(_ctx, State);
		EnterRule(_localctx, 20, RULE_logicaloperator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 123;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__4) | (1L << T__3) | (1L << T__2) | (1L << T__1))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RelationaloperatorContext : ParserRuleContext {
		public ITerminalNode EQUAL() { return GetToken(OCLExpressionParser.EQUAL, 0); }
		public ITerminalNode GE() { return GetToken(OCLExpressionParser.GE, 0); }
		public ITerminalNode NEQUAL() { return GetToken(OCLExpressionParser.NEQUAL, 0); }
		public ITerminalNode LT() { return GetToken(OCLExpressionParser.LT, 0); }
		public ITerminalNode GT() { return GetToken(OCLExpressionParser.GT, 0); }
		public ITerminalNode LE() { return GetToken(OCLExpressionParser.LE, 0); }
		public RelationaloperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relationaloperator; } }
		public override void EnterRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.EnterRelationaloperator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.ExitRelationaloperator(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IOCLExpressionVisitor<TResult> typedVisitor = visitor as IOCLExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelationaloperator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RelationaloperatorContext relationaloperator() {
		RelationaloperatorContext _localctx = new RelationaloperatorContext(_ctx, State);
		EnterRule(_localctx, 22, RULE_relationaloperator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 125;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << EQUAL) | (1L << NEQUAL) | (1L << LT) | (1L << GT) | (1L << LE) | (1L << GE))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AddoperatorContext : ParserRuleContext {
		public ITerminalNode PLUS() { return GetToken(OCLExpressionParser.PLUS, 0); }
		public ITerminalNode MINUS() { return GetToken(OCLExpressionParser.MINUS, 0); }
		public AddoperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_addoperator; } }
		public override void EnterRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.EnterAddoperator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.ExitAddoperator(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IOCLExpressionVisitor<TResult> typedVisitor = visitor as IOCLExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAddoperator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AddoperatorContext addoperator() {
		AddoperatorContext _localctx = new AddoperatorContext(_ctx, State);
		EnterRule(_localctx, 24, RULE_addoperator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 127;
			_la = _input.La(1);
			if ( !(_la==PLUS || _la==MINUS) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultiplyoperatorContext : ParserRuleContext {
		public ITerminalNode MULT() { return GetToken(OCLExpressionParser.MULT, 0); }
		public ITerminalNode DIVIDE() { return GetToken(OCLExpressionParser.DIVIDE, 0); }
		public MultiplyoperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiplyoperator; } }
		public override void EnterRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.EnterMultiplyoperator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.ExitMultiplyoperator(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IOCLExpressionVisitor<TResult> typedVisitor = visitor as IOCLExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiplyoperator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MultiplyoperatorContext multiplyoperator() {
		MultiplyoperatorContext _localctx = new MultiplyoperatorContext(_ctx, State);
		EnterRule(_localctx, 26, RULE_multiplyoperator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 129;
			_la = _input.La(1);
			if ( !(_la==MULT || _la==DIVIDE) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnaryoperatorContext : ParserRuleContext {
		public ITerminalNode MINUS() { return GetToken(OCLExpressionParser.MINUS, 0); }
		public UnaryoperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unaryoperator; } }
		public override void EnterRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.EnterUnaryoperator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.ExitUnaryoperator(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IOCLExpressionVisitor<TResult> typedVisitor = visitor as IOCLExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnaryoperator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnaryoperatorContext unaryoperator() {
		UnaryoperatorContext _localctx = new UnaryoperatorContext(_ctx, State);
		EnterRule(_localctx, 28, RULE_unaryoperator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 131;
			_la = _input.La(1);
			if ( !(_la==T__0 || _la==MINUS) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumericalconstantContext : ParserRuleContext {
		public FloatContext @float() {
			return GetRuleContext<FloatContext>(0);
		}
		public IntegerContext integer() {
			return GetRuleContext<IntegerContext>(0);
		}
		public NumericalconstantContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numericalconstant; } }
		public override void EnterRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.EnterNumericalconstant(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.ExitNumericalconstant(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IOCLExpressionVisitor<TResult> typedVisitor = visitor as IOCLExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumericalconstant(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumericalconstantContext numericalconstant() {
		NumericalconstantContext _localctx = new NumericalconstantContext(_ctx, State);
		EnterRule(_localctx, 30, RULE_numericalconstant);
		try {
			State = 135;
			switch ( Interpreter.AdaptivePredict(_input,8,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 133; integer();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 134; @float();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IntegerContext : ParserRuleContext {
		public ITerminalNode DIGIT(int i) {
			return GetToken(OCLExpressionParser.DIGIT, i);
		}
		public ITerminalNode[] DIGIT() { return GetTokens(OCLExpressionParser.DIGIT); }
		public IntegerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_integer; } }
		public override void EnterRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.EnterInteger(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.ExitInteger(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IOCLExpressionVisitor<TResult> typedVisitor = visitor as IOCLExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInteger(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IntegerContext integer() {
		IntegerContext _localctx = new IntegerContext(_ctx, State);
		EnterRule(_localctx, 32, RULE_integer);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 138;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 137; Match(DIGIT);
				}
				}
				State = 140;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==DIGIT );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FloatContext : ParserRuleContext {
		public ITerminalNode DIGIT(int i) {
			return GetToken(OCLExpressionParser.DIGIT, i);
		}
		public ITerminalNode[] DIGIT() { return GetTokens(OCLExpressionParser.DIGIT); }
		public FloatContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_float; } }
		public override void EnterRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.EnterFloat(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IOCLExpressionListener typedListener = listener as IOCLExpressionListener;
			if (typedListener != null) typedListener.ExitFloat(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IOCLExpressionVisitor<TResult> typedVisitor = visitor as IOCLExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFloat(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FloatContext @float() {
		FloatContext _localctx = new FloatContext(_ctx, State);
		EnterRule(_localctx, 34, RULE_float);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 143;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 142; Match(DIGIT);
				}
				}
				State = 145;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==DIGIT );
			State = 147; Match(DOT);
			State = 149;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 148; Match(DIGIT);
				}
				}
				State = 151;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==DIGIT );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3\x1C\x9C\x4\x2\t"+
		"\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4\t"+
		"\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10"+
		"\t\x10\x4\x11\t\x11\x4\x12\t\x12\x4\x13\t\x13\x3\x2\x3\x2\x3\x3\x3\x3"+
		"\x3\x3\x3\x3\a\x3-\n\x3\f\x3\xE\x3\x30\v\x3\x3\x4\x3\x4\x3\x4\x3\x4\x3"+
		"\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4"+
		"\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\a\x4L\n\x4"+
		"\f\x4\xE\x4O\v\x4\x3\x5\x3\x5\x3\x5\x3\x5\a\x5U\n\x5\f\x5\xE\x5X\v\x5"+
		"\x3\x6\x3\x6\x3\x6\x3\x6\a\x6^\n\x6\f\x6\xE\x6\x61\v\x6\x3\a\x3\a\x3\a"+
		"\x3\a\x5\ag\n\a\x3\b\x3\b\x3\b\x3\b\x3\b\a\bn\n\b\f\b\xE\bq\v\b\x3\t\x3"+
		"\t\x3\t\x3\t\x3\t\x5\tx\n\t\x3\n\x3\n\x3\v\x3\v\x3\f\x3\f\x3\r\x3\r\x3"+
		"\xE\x3\xE\x3\xF\x3\xF\x3\x10\x3\x10\x3\x11\x3\x11\x5\x11\x8A\n\x11\x3"+
		"\x12\x6\x12\x8D\n\x12\r\x12\xE\x12\x8E\x3\x13\x6\x13\x92\n\x13\r\x13\xE"+
		"\x13\x93\x3\x13\x3\x13\x6\x13\x98\n\x13\r\x13\xE\x13\x99\x3\x13\x2\x2"+
		"\x2\x14\x2\x2\x4\x2\x6\x2\b\x2\n\x2\f\x2\xE\x2\x10\x2\x12\x2\x14\x2\x16"+
		"\x2\x18\x2\x1A\x2\x1C\x2\x1E\x2 \x2\"\x2$\x2\x2\a\x3\x2\x3\x6\x3\x2\v"+
		"\x10\x3\x2\x16\x17\x3\x2\x18\x19\x4\x2\a\a\x17\x17\x99\x2&\x3\x2\x2\x2"+
		"\x4(\x3\x2\x2\x2\x6\x31\x3\x2\x2\x2\bP\x3\x2\x2\x2\nY\x3\x2\x2\x2\f\x66"+
		"\x3\x2\x2\x2\xEh\x3\x2\x2\x2\x10w\x3\x2\x2\x2\x12y\x3\x2\x2\x2\x14{\x3"+
		"\x2\x2\x2\x16}\x3\x2\x2\x2\x18\x7F\x3\x2\x2\x2\x1A\x81\x3\x2\x2\x2\x1C"+
		"\x83\x3\x2\x2\x2\x1E\x85\x3\x2\x2\x2 \x89\x3\x2\x2\x2\"\x8C\x3\x2\x2\x2"+
		"$\x91\x3\x2\x2\x2&\'\x5\x4\x3\x2\'\x3\x3\x2\x2\x2(.\x5\x6\x4\x2)*\x5\x16"+
		"\f\x2*+\x5\x6\x4\x2+-\x3\x2\x2\x2,)\x3\x2\x2\x2-\x30\x3\x2\x2\x2.,\x3"+
		"\x2\x2\x2./\x3\x2\x2\x2/\x5\x3\x2\x2\x2\x30.\x3\x2\x2\x2\x31\x32\x5\b"+
		"\x5\x2\x32M\b\x4\x1\x2\x33\x34\a\v\x2\x2\x34\x35\x5\b\x5\x2\x35\x36\b"+
		"\x4\x1\x2\x36L\x3\x2\x2\x2\x37\x38\a\f\x2\x2\x38\x39\x5\b\x5\x2\x39:\b"+
		"\x4\x1\x2:L\x3\x2\x2\x2;<\a\r\x2\x2<=\x5\b\x5\x2=>\b\x4\x1\x2>L\x3\x2"+
		"\x2\x2?@\a\xE\x2\x2@\x41\x5\b\x5\x2\x41\x42\b\x4\x1\x2\x42L\x3\x2\x2\x2"+
		"\x43\x44\a\x10\x2\x2\x44\x45\x5\b\x5\x2\x45\x46\b\x4\x1\x2\x46L\x3\x2"+
		"\x2\x2GH\a\xF\x2\x2HI\x5\b\x5\x2IJ\b\x4\x1\x2JL\x3\x2\x2\x2K\x33\x3\x2"+
		"\x2\x2K\x37\x3\x2\x2\x2K;\x3\x2\x2\x2K?\x3\x2\x2\x2K\x43\x3\x2\x2\x2K"+
		"G\x3\x2\x2\x2LO\x3\x2\x2\x2MK\x3\x2\x2\x2MN\x3\x2\x2\x2N\a\x3\x2\x2\x2"+
		"OM\x3\x2\x2\x2PV\x5\n\x6\x2QR\x5\x1A\xE\x2RS\x5\n\x6\x2SU\x3\x2\x2\x2"+
		"TQ\x3\x2\x2\x2UX\x3\x2\x2\x2VT\x3\x2\x2\x2VW\x3\x2\x2\x2W\t\x3\x2\x2\x2"+
		"XV\x3\x2\x2\x2Y_\x5\f\a\x2Z[\x5\x1C\xF\x2[\\\x5\f\a\x2\\^\x3\x2\x2\x2"+
		"]Z\x3\x2\x2\x2^\x61\x3\x2\x2\x2_]\x3\x2\x2\x2_`\x3\x2\x2\x2`\v\x3\x2\x2"+
		"\x2\x61_\x3\x2\x2\x2\x62\x63\x5\x1E\x10\x2\x63\x64\x5\xE\b\x2\x64g\x3"+
		"\x2\x2\x2\x65g\x5\xE\b\x2\x66\x62\x3\x2\x2\x2\x66\x65\x3\x2\x2\x2g\r\x3"+
		"\x2\x2\x2ho\x5\x10\t\x2ij\a\x13\x2\x2jk\x5\x12\n\x2kl\b\b\x1\x2ln\x3\x2"+
		"\x2\x2mi\x3\x2\x2\x2nq\x3\x2\x2\x2om\x3\x2\x2\x2op\x3\x2\x2\x2p\xF\x3"+
		"\x2\x2\x2qo\x3\x2\x2\x2rs\a\x1B\x2\x2sx\b\t\x1\x2tu\x5 \x11\x2uv\b\t\x1"+
		"\x2vx\x3\x2\x2\x2wr\x3\x2\x2\x2wt\x3\x2\x2\x2x\x11\x3\x2\x2\x2yz\x5\x14"+
		"\v\x2z\x13\x3\x2\x2\x2{|\a\x1B\x2\x2|\x15\x3\x2\x2\x2}~\t\x2\x2\x2~\x17"+
		"\x3\x2\x2\x2\x7F\x80\t\x3\x2\x2\x80\x19\x3\x2\x2\x2\x81\x82\t\x4\x2\x2"+
		"\x82\x1B\x3\x2\x2\x2\x83\x84\t\x5\x2\x2\x84\x1D\x3\x2\x2\x2\x85\x86\t"+
		"\x6\x2\x2\x86\x1F\x3\x2\x2\x2\x87\x8A\x5\"\x12\x2\x88\x8A\x5$\x13\x2\x89"+
		"\x87\x3\x2\x2\x2\x89\x88\x3\x2\x2\x2\x8A!\x3\x2\x2\x2\x8B\x8D\a\x1A\x2"+
		"\x2\x8C\x8B\x3\x2\x2\x2\x8D\x8E\x3\x2\x2\x2\x8E\x8C\x3\x2\x2\x2\x8E\x8F"+
		"\x3\x2\x2\x2\x8F#\x3\x2\x2\x2\x90\x92\a\x1A\x2\x2\x91\x90\x3\x2\x2\x2"+
		"\x92\x93\x3\x2\x2\x2\x93\x91\x3\x2\x2\x2\x93\x94\x3\x2\x2\x2\x94\x95\x3"+
		"\x2\x2\x2\x95\x97\a\x13\x2\x2\x96\x98\a\x1A\x2\x2\x97\x96\x3\x2\x2\x2"+
		"\x98\x99\x3\x2\x2\x2\x99\x97\x3\x2\x2\x2\x99\x9A\x3\x2\x2\x2\x9A%\x3\x2"+
		"\x2\x2\xE.KMV_\x66ow\x89\x8E\x93\x99";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace Mascaret
